---
title: "STAT 385 Fall 2019 - Homework Assignment 03"
author: "Tianli Ding"
date: "Due by 12:00 PM 10/12/2019"
output: html_document
---

## The Homework Problems

Below you will find problems for you to complete as an individual. It is fine to discuss the homework problems with classmates, but cheating is prohibited and will be harshly penalized if detected.


### 1. Create a custom volume measurement function that will convert the following units of volume:
a. 13 imperial (liquid) cups to cubic inches.
b. 2.5 US customary (liquid) gallons to fluid ounces.
c. 3 US customary (dry) teaspoons to milliliters.
d. 75 (dry) liters to imperial quarts.
```{r}
converter <- function(type1, type2, x){
a = "cups"
b = "cubic inches"
c = "gallons"
d = "ounces"
e = "teaspoons"
f = "milliliters"
g = "liters"
h = "quarts"
if(type1 == a && type2 == b) return(x*14.4375)
else if(type1 == c && type2 == d) return(x*128)
else if(type1 == e && type2 == f) return(x*4.92892)
else if(type1 == g && type2 == h) return(x*0.879877)
}
## a.
converter("cups", "cubic inches", 13)
## b.
converter("gallons", "ounces", 2.5)
## c.
converter("teaspoons", "milliliters", 3)
## d.
converter("liters", "quarts", 75)
```


### 2. Do the following:

a. create a 25 $\times$ 25 matrix with autoregressive structure with $p = 9/10$, every element in the matrix should be equal to $(9/10)^{|i-j|}$ where `i` is the row index and `j` is the column index.  Report the row and column sums of this matrix.

```{r}
A = matrix(rep(0,625), 25,25)
for(i in 1:25){
  for(j in 1:25){
    A[i,j] = (9/10)^(abs(i-j))
  }
}
#column sum and row sum
apply(A,2,sum)
apply(A,1,sum)
```

b. run the commands:
```{r}
set.seed(13)
x <- c(10, 10) 
n <- 2
```

Create a while loop which concatenates a new mean-zero normal random variables that have $\sigma = 2$ to the existing vector `x` at every iteration.  Have this loop terminate when the standard error (estimated standard deviation of `x` divided by $\sqrt{n}$) is lower than 1/10.  Report $n$. 
```{r}
while(1){
  x = append(x, rnorm(1,0,2))
  n = n+1
  se = sd(x)/sqrt(n)
  if(se < 1/10) break;
}
n
```

c. repeat part **b** and report $n$ after running the commands:    

```{r}
set.seed(13)
x <- rnorm(1, 0, 2)
n <- 1
```

```{r}
while(1){
  x = append(x, rnorm(1,0,2))
  n = n+1
  se2 = sd(x)/sqrt(n)
  if(se2 < 1/10) break;
}
n
```

d. The sample size required to get a standard error lower than 1/10 was smaller in part **c** than it was in part **b**.  We would expect for this to be the case before we ran any code.  Why?

Since the **b** starts with two 10s. Then we add the third value (one mean-zero normal random variable which have sigma = 2) which will lead to large sd, thus indicating we will have large se as well. However, we start with one (mean-zero normal random variable which have sigma = 2) value, then we add a second value. It won't diplay large sd and se. Therefore, it takes more values to balance back the sd in question b than c.

### 3. Do the following (Efron's bootstrap):

a. load in the dataset [dataHW3.csv](https://uofi.box.com/shared/static/mwntzgp2rvyewf292k6i62pykjz1onnw.csv)
```{r}
dataset = read.csv("https://uofi.box.com/shared/static/mwntzgp2rvyewf292k6i62pykjz1onnw.csv")
```

b. call the first column of this dataset x. Compute the statistic `(mean(x) - 10)/se(x)` where `se` is shorthand for standard error (see the previous problem for the definition of standard error).  
```{r}
x = dataset[,1]
se <- function(x){ return(sd(x)/sqrt(length(x)))}
stat = (mean(x)-10)/se(x)
stat
```

c. now resample the elements of x with replacement 10000 times, and compute and store the statistic (mean(x') - mean(x))/se(x') at each iteration where x' corresponds to the resample of the elements of x. Call the vector which contains these reasampled statistics `resamples'.  Use an apply function for this part.  

```{r}
library(gdata)
resamples = vector()
for(i in 1:10000){
  resamples = rbind(resamples, resample(x, replace = TRUE))
}
diff = (apply(resamples,1, mean) - mean(x))/apply(resamples,1,se)
```

d.  run the command `hist(resamples, breaks = 20)' to make a histogram, include this histogram in your assignment.
```{r}
hist(resamples, breaks = 20)
```

e. repeat parts **b** through **d** with respect to the second column of dataHW3.csv.  Would you say that the test statistic calculated from each column has the same distribution?
```{r}
x2 = dataset[,2]
stat2 = (mean(x2)-10)/se(x2)
print(stat2)

resamples2 = vector()
for(i in 1:10000){
  resamples2 = rbind(resamples2, resample(x2, replace = TRUE))
}
diff2 = (apply(resamples2,1, mean) - mean(x2))/apply(resamples2,1,se)
```
```{r}
hist(resamples2, breaks = 20)
```
No, the test statistics from the first and second columns does not have the same distribution.



### 4. Do the following:

a. make sure you have the dataset [WPP2010.csv](https://uofi.box.com/shared/static/vielwghs3qtdf2p25nejeiaq6ce9nonf.csv) (your file location may need to change) and then run the commands: 

```{r}
# load in UN dataset and remove irrelevant variables
options(warn=-1)
WPP2010 <- read.csv("WPP2010.csv", header = TRUE)
# name the third column "region"
colnames(WPP2010)[3] <- c("region")
# name the sixth column "year"
colnames(WPP2010)[6] <- c("year")
# change the name from column 7th to 17th to age+number from 0 to 50, interval as 5
colnames(WPP2010)[7:17] <- paste("age", 0:10 * 5, sep = "")
# select only the 3rd, 6th, 11th, 12th column from WPP2010, and save it as new WPP2010
WPP2010 <- WPP2010[, c(3, 6, 11, 12)]
# restrict attention to countries of interest
countries <- c("Canada", "Mexico", "United States of America")
# obtain population data for all countries for all years
dataset <- WPP2010[WPP2010[, 1] %in% countries, ]
# change the 3rd column of dataset from factor to numeric
dataset[, 3] <- as.numeric(levels(dataset[, 3]))[dataset[, 3]]
# change the 4th column of dataset from factor to numeric
dataset[, 4] <- as.numeric(levels(dataset[, 4]))[dataset[, 4]]
# have all the value in 3rd and 4th column in dataset divided by 1000
dataset[, 3:4] <- dataset[, 3:4] / 1000
# get population dataset for this analysis corresponding to the Census years 
dataset.years <- dataset[dataset[, 2] %in% c("1960", "1970", "1980", "1990", "2000", "2010"), ]
# turn the second column(year) in dataset as factor
dataset.years[, 2] <- factor(dataset.years[, 2])
# divide the dataset.years into a list, which group by different year (factor)
dataset.years.list <- split(dataset.years, f = as.factor(dataset.years[, 2]))
# lapply() function sums the values from 3rd and 4th column in dataset.years.list, indexing by the year, then the unlist() function simplifies the new dataset.years.list into a vector, then save into pops
pops <- unlist(lapply(dataset.years.list, function(x) sum(x[, 3:4])))
```



b. The code in part **a** is partially commented.  Add comments to all remaining lines of code to make the script clear.


c. Determine the proportion of mainland North American males aged 20-29 that lived in 1970 or before.
```{r}
dataset$year = as.numeric(as.character(dataset$year))
newdataset = filter(dataset, dataset$year <= 1970)
proportion = sum(newdataset[, 3:4])/sum(dataset[,3:4])
proportion
```
The proportion of mainland North American males aged 20-29 that lived in 1970 or before is 0.1876567

### 5. With the tidyverse package and its functions, do the following with the [CCSO Bookings Data](https://uofi.box.com/shared/static/9elozjsg99bgcb7gb546wlfr3r2gc9b7.csv):

a. show only the 2012 bookings for people ages 17-23 years old not residing in Illinois and show the data dimension
```{r, message=FALSE}
library(bit64)
library(dplyr)
ccso = read.csv("https://uofi.box.com/shared/static/9elozjsg99bgcb7gb546wlfr3r2gc9b7.csv")
```


```{r}
newa = filter(ccso,  Age.at.Arrest >= 17 & Age.at.Arrest <= 23 & ccso$STATE != "ILLINOIS" & as.Date(ccso$BOOKING.DATE, "%m/%d/%Y") >= "2012/01/01" & as.Date(ccso$BOOKING.DATE, "%m/%d/%Y") < "2013/01/01")
dim(newa)
```

b. show only the bookings for people who have employment status as "student" booked after the year 2012 residing in Danville and show the data dimension
```{r}
newb = filter(ccso, EMPLOYMENT.STATUS == "Student" & CITY == "DANVILLE" & as.Date(ccso$BOOKING.DATE, "%m/%d/%Y") >= "2013/01/01")
dim(newb)
```

c. show only the bookings for Asian people residing in the cities of Champaign or Urbana and show the data dimension
```{r}
newc = filter(ccso, CITY == "CHAMPAIGN" | CITY == "URBANA", RACE == "Asian/Pacific Islander" )
dim(newc)
```

d. repeat parts a-c using only pipe operators
```{r, eval = FALSE}
## a
ccso %>% filter(Age.at.Arrest >= 17 & Age.at.Arrest <= 23 & ccso$STATE != "ILLINOIS" & as.Date(ccso$BOOKING.DATE, "%m/%d/%Y") >= "2012/01/01" & as.Date(ccso$BOOKING.DATE, "%m/%d/%Y") < "2013/01/01")
```
```{r, eval= FALSE}
## b
ccso %>% filter(Age.at.Arrest >= 17 & Age.at.Arrest <= 23 & ccso$STATE != "ILLINOIS" & as.Date(ccso$BOOKING.DATE, "%m/%d/%Y") >= "2012/01/01" & as.Date(ccso$BOOKING.DATE, "%m/%d/%Y") < "2013/01/01")
```
```{r, eval= FALSE}
## c
ccso %>% filter(CITY == "CHAMPAIGN" | CITY == "URBANA", RACE == "Asian/Pacific Islander")
```


